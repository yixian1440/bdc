## 问题分析

用户要求实现基于**开发商转移案件历史总量**的平均分配逻辑：
- 核心需求：让每个收件人的累计案件数量尽可能平均
- 具体规则：若A历史5件、B历史6件，下次分配应给A
- 适用范围：仅开发商转移案件

## 解决方案

修改 `allocationModule.js` 中的 `handleDeveloperTransferAllocation` 函数，实现基于**历史总量**的平均分配：

### 1. 核心修改点

**文件**：`backend/routes/modules/allocationModule.js`
**函数**：`handleDeveloperTransferAllocation`
**影响范围**：仅开发商转移案件的分配逻辑

### 2. 实现逻辑

1. **获取可用收件人**：
   ```javascript
   // 获取所有可用收件人（收件人和国资企业专窗）
   const [availableReceivers] = await db.execute(
       `SELECT id, real_name 
        FROM users 
        WHERE role IN (?, ?) 
        ORDER BY id`,
       ['收件人', '国资企业专窗']
   );
   ```

2. **统计历史案件数量**：
   ```javascript
   // 统计每个收件人历史上的开发商转移案件数量
   const [historyCaseCounts] = await db.execute(
       `SELECT receiver_id, COUNT(*) as case_count 
        FROM cases 
        WHERE case_type IN ('开发商转移', '开发商转移登记') 
        GROUP BY receiver_id`
   );
   ```

3. **计算每个收件人的历史案件数**：
   ```javascript
   // 将查询结果转换为Map，便于快速查找
   const caseCountMap = new Map(historyCaseCounts.map(item => [item.receiver_id, item.case_count]));
   
   // 为每个可用收件人添加历史案件数
   const receiversWithCount = availableReceivers.map(receiver => ({
       ...receiver,
       case_count: caseCountMap.get(receiver.id) || 0
   }));
   ```

4. **选择历史案件数最少的收件人**：
   ```javascript
   // 按历史案件数升序排序，若案件数相同则按ID升序排序
   receiversWithCount.sort((a, b) => {
       // 首先按案件数排序
       if (a.case_count !== b.case_count) {
           return a.case_count - b.case_count;
       }
       // 案件数相同时，按ID排序作为tiebreaker
       return a.id - b.id;
   });
   
   // 选择历史案件数最少的收件人
   const nextReceiver = receiversWithCount[0];
   ```

### 3. 预期效果

1. **平均分配**：每个收件人的累计案件数量差异将控制在1件以内
2. **历史均衡**：考虑了每个收件人的历史工作量
3. **公平合理**：分配结果更符合"平均分配"的要求
4. **稳定可靠**：若有平局，使用ID排序确保分配结果稳定

### 4. 验证方式

1. **数据验证**：
   - 运行分配逻辑后，检查每个收件人的历史案件数量
   - 确保差异不超过1件

2. **实际测试**：
   - 创建多个开发商转移案件
   - 检查分配结果是否符合预期

### 5. 向后兼容

- 仅修改开发商转移案件的分配逻辑
- 不影响其他案件类型的分配
- 保持原有函数签名不变，确保调用方无需修改

通过这个修改，将实现用户要求的基于历史总量的平均分配逻辑，确保开发商转移案件在收件人间均匀分配。